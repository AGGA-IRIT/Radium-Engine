#include <Engine/Managers/MeshContactManager/MeshContactElement.hpp>

#include <queue>
#include <iostream>

#include <Engine/Managers/ComponentMessenger/ComponentMessenger.hpp>

#include <Core/Mesh/TriangleMesh.hpp>
#include <Core/Mesh/Wrapper/Convert.hpp>
#include <Core/Mesh/DCEL/Dcel.hpp>
#include <Core/Mesh/DCEL/Operations/EdgeCollapse.hpp>
#include <Core/Geometry/Normal/Normal.hpp>
#include <Core/Index/Index.hpp>
#include <Core/Mesh/ProgressiveMesh/PriorityQueue.hpp>
#include <Core/Mesh/ProgressiveMesh/ProgressiveMesh.hpp>

#include <Engine/Renderer/RenderObject/RenderObjectManager.hpp>
#include <Engine/Assets/GeometryData.hpp>
#include <Engine/Managers/SystemDisplay/SystemDisplay.hpp>

#include <Core/TreeStructures/kdtree.hpp>
#include <Core/Mesh/DCEL/Face.hpp>
#include <Core/Mesh/ProgressiveMesh/PriorityQueue.hpp>

namespace Ra
{
    namespace Engine
    {
        MeshContactElement::MeshContactElement(
        ComponentMessenger::CallbackTypes<Ra::Core::Vector3Array>::ReadWrite verticesWriter,
        ComponentMessenger::CallbackTypes<Ra::Core::Vector3Array>::ReadWrite normalsWriter,
        ComponentMessenger::CallbackTypes<TriangleArray>::ReadWrite trianglesWriter
        )
        {
            m_verticesWriter = verticesWriter;
            m_normalsWriter = normalsWriter;
            m_trianglesWriter = trianglesWriter;
        }

        void MeshContactElement::lodValueChanged(int value)
        {
            // Retrieving the data of the displayed mesh
            Ra::Core::Vector3Array& vertices = *(m_verticesWriter());
            Ra::Core::Vector3Array& normals = *(m_normalsWriter());
            TriangleArray& triangles = *(m_trianglesWriter());

            // Go to LOD with 'value' number of faces
            TriangleMesh mNew = m_pmlod->gotoM(value);

            // Update of the data of the displayed mesh
            triangles = mNew.m_triangles;
            vertices = mNew.m_vertices;
            Ra::Core::Geometry::uniformNormal(vertices, triangles, normals);
        }


        Super4PCS::KdTree<float>* MeshContactComponent::computeKdTree()
        {
            const Super4PCS::KdTree<float>::PointList& points = reinterpret_cast<const Super4PCS::KdTree<float>::PointList&>(*(m_verticesWriter()));
            return (new Super4PCS::KdTree<float>(points));
        }

        Ra::Core::PriorityQueue* MeshContactComponent::getPriorityQueue()
        {
            return m_pqueue;
        }

        void MeshContactComponent::setPriorityQueue(Ra::Core::PriorityQueue pQueue)
        {
            m_pqueue = new Ra::Core::PriorityQueue(pQueue);
        }

        void MeshContactComponent::computeProgressiveMesh()
        {
            Ra::Core::Vector3Array& vertices = *(m_verticesWriter());
            Ra::Core::Vector3Array& normals = *(m_normalsWriter());
            TriangleArray& triangles = *(m_trianglesWriter());

            Ra::Core::TriangleMesh* m = new Ra::Core::TriangleMesh();
            m->m_vertices = vertices;
            m->m_normals = normals;
            m->m_triangles = triangles;

            Ra::Core::ProgressiveMeshBase<>* pm = new Ra::Core::ProgressiveMesh<>(m);
            m_pmlod = new Ra::Core::ProgressiveMeshLOD(pm);


        }

        Ra::Core::ProgressiveMeshLOD* MeshContactComponent::getProgressiveMeshLOD()
        {
            return m_pmlod;
        }

        void MeshContactComponent::updateTriangleMesh(Ra::Core::TriangleMesh newMesh)
        {
            Ra::Core::Vector3Array& vertices = *(m_verticesWriter());
            Ra::Core::Vector3Array& normals = *(m_normalsWriter());
            TriangleArray& triangles = *(m_trianglesWriter());

            vertices = newMesh.m_vertices;
            triangles = newMesh.m_triangles;
            for(int i =0;i<newMesh.m_vertices.size();i++)
            {
                 Ra::Core::Vector3 p = newMesh.m_vertices[i];
            }
            for(int i =0;i<newMesh.m_triangles.size();i++)
            {
                 Ra::Core::Triangle t = newMesh.m_triangles[i];
            }
            Ra::Core::Geometry::uniformNormal(vertices, triangles, normals);
        }

        void MeshContactComponent::computePrimitives()
        {

            // We retrieve the initial faces quadrics
            std::vector<Ra::Core::ProgressiveMesh<>::Primitive> facesPrimitives = getProgressiveMeshLOD()->getProgressiveMesh()->getFacesQuadrics();

            int nbVertex = getProgressiveMeshLOD()->getProgressiveMesh()->getDcel()->m_vertex.size();

            for (uint v = 0; v < nbVertex; v++)
            {
                // We go all over the faces which contain vertexIndex
                Ra::Core::VFIterator vfIt = Ra::Core::VFIterator(getProgressiveMeshLOD()->getProgressiveMesh()->getDcel()->m_vertex[v]);
                Ra::Core::FaceList adjFaces = vfIt.list();

                Ra::Core::ProgressiveMesh<>::Primitive q = facesPrimitives[adjFaces[0]->idx];


                for (uint i = 1; i < adjFaces.size(); i++)
                {
                    q += facesPrimitives[adjFaces[i]->idx];
                }

                Scalar weight = 1.0/adjFaces.size();
                q *= weight;

                m_primitives.push_back(q);
            }

         }

         Ra::Core::ProgressiveMesh<>::Primitive MeshContactComponent::getPrimitive(int vertexIndex)
         {
             return m_primitives[vertexIndex];
         }

         void MeshContactComponent::setIndex(int idx)
         {
             m_index = idx;
         }

         int MeshContactComponent::getIndex()
         {
             return m_index;
         }

    }
}
